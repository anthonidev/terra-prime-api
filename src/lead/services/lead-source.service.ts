import {  Injectable,  ConflictException,  NotFoundException,  InternalServerErrorException,  Logger,} from '@nestjs/common';import { InjectRepository } from '@nestjs/typeorm';import { FindOptionsWhere, ILike, Repository } from 'typeorm';import { LeadSource } from '../entities/lead-source.entity';import {  CreateLeadSourceDto,  UpdateLeadSourceDto,} from '../dto/lead-source.dto';import { FindLeadSourcesDto } from '../dto/find-lead-sources.dto';import {  PaginatedResult,  PaginationHelper,} from '../../common/helpers/pagination.helper';@Injectable()export class LeadSourceService {  private readonly logger = new Logger(LeadSourceService.name);  constructor(    @InjectRepository(LeadSource)    private readonly leadSourceRepository: Repository<LeadSource>,  ) {}  async create(createLeadSourceDto: CreateLeadSourceDto): Promise<LeadSource> {    try {      const existingSource = await this.leadSourceRepository.findOne({        where: {          name: createLeadSourceDto.name,        },      });      if (existingSource) {        throw new ConflictException(          `Ya existe una fuente con el nombre "${createLeadSourceDto.name}"`,        );      }      const leadSource = this.leadSourceRepository.create(createLeadSourceDto);      return await this.leadSourceRepository.save(leadSource);    } catch (error) {      if (error instanceof ConflictException) {        throw error;      }      this.logger.error(`Error al crear fuente: ${error.message}`, error.stack);      throw new InternalServerErrorException('Error al crear la fuente');    }  }  async update(    id: number,    updateLeadSourceDto: UpdateLeadSourceDto,  ): Promise<LeadSource> {    try {      const leadSource = await this.leadSourceRepository.findOne({        where: { id },      });      if (!leadSource) {        throw new NotFoundException(`Fuente con ID ${id} no encontrada`);      }      if (        updateLeadSourceDto.name &&        updateLeadSourceDto.name !== leadSource.name      ) {        const existingSource = await this.leadSourceRepository.findOne({          where: {            name: updateLeadSourceDto.name,          },        });        if (existingSource && existingSource.id !== id) {          throw new ConflictException(            `Ya existe una fuente con el nombre "${updateLeadSourceDto.name}"`,          );        }      }      await this.leadSourceRepository.update(id, updateLeadSourceDto);      return await this.leadSourceRepository.findOne({ where: { id } });    } catch (error) {      if (        error instanceof NotFoundException ||        error instanceof ConflictException      ) {        throw error;      }      this.logger.error(        `Error al actualizar fuente: ${error.message}`,        error.stack,      );      throw new InternalServerErrorException('Error al actualizar la fuente');    }  }  async findById(id: number): Promise<LeadSource> {    try {      const leadSource = await this.leadSourceRepository.findOne({        where: { id },      });      if (!leadSource) {        throw new NotFoundException(`Fuente con ID ${id} no encontrada`);      }      return leadSource;    } catch (error) {      if (error instanceof NotFoundException) {        throw error;      }      this.logger.error(        `Error al buscar fuente: ${error.message}`,        error.stack,      );      throw new InternalServerErrorException('Error al buscar la fuente');    }  }  async findAll(    filters: FindLeadSourcesDto,  ): Promise<PaginatedResult<LeadSource>> {    try {      const {        page = 1,        limit = 10,        search,        isActive,        order = 'DESC',      } = filters;      const where: FindOptionsWhere<LeadSource> = {};      if (isActive !== undefined) {        where.isActive = isActive;      }      if (search) {        const searchTerm = `%${search.toLowerCase()}%`;        where.name = ILike(searchTerm);      }      const [items, totalItems] = await this.leadSourceRepository.findAndCount({        where,        order: {          createdAt: order,        },        skip: (page - 1) * limit,        take: limit,      });      return PaginationHelper.createPaginatedResponse(        items,        totalItems,        filters,      );    } catch (error) {      this.logger.error(        `Error al listar fuentes: ${error.message}`,        error.stack,      );      throw new InternalServerErrorException('Error al listar las fuentes');    }  }  async findAllActive(): Promise<LeadSource[]> {    try {      return await this.leadSourceRepository.find({        where: { isActive: true },        order: { name: 'ASC' },      });    } catch (error) {      this.logger.error(        `Error al listar fuentes activas: ${error.message}`,        error.stack,      );      throw new InternalServerErrorException(        'Error al listar las fuentes activas',      );    }  }}